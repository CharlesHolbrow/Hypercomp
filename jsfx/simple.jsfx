desc: 'A simple meter that utilizes js gfx scripting'

slider1:0<0, 1, 0.01>first
slider2:1<0, 4, 1>second


@slider
shift_left = slider1 * $pi;


@init
// How big is the region we render to?
box_width = 360;
box_height = 360;
border = 2;

// Cached constants
box_width_inverse = 1 / box_width;
box_height_inverse = 1 / box_height;
sqrt2 = sqrt(2);

malloc_ptr = 0;
function malloc(size)(
  this.ptr = malloc_ptr;
  this.i = 0;
  loop(size,
    malloc_ptr[this.i] = 0;
    this.i += 1;
  );
  malloc_ptr += size;
  this.ptr;
);

function create_buffer(size_samples)(
  this.buff = malloc(size_samples + 4);
  // the first four memory locations store meta-data about the buffer
  // - buff[0] stores the size of the audio buffer in samples
  // - buff[1] stores the position where we will place the next sample (relative to this.buff)
  // - buff[2] stores the sum of the square of each sample
  // - buff[3] stores the RMS over the buffer
  this.buff[0] = size_samples;
  this.buff[1] = 4;
  this.buff;
);

// Add a value to the buffer, keeping all meta-data up to date.
function buff_push(buff, value)(
  buff[2] -= pow(buff[buff[1]], 2);
  buff[buff[1]] = value;
  buff[2] += pow(value, 2);
  buff[3] = sqrt(buff[2] / buff[0]);

  buff[1] += 1;
  buff[1] >= (buff[0] + 4) ? (buff[1] = 4;);
);

function buff_rms(buff)(
  buff[3];
);

////////////////////////////////////////////////////////////////
//
// For a given azimuth and elevation, calculate the level. The
// units of both arguments are integers relative to box_height
// and box_width.
//
////////////////////////////////////////////////////////////////
function calculate_level(azimuth elevation)(
  this.elevation_mult = sin_azimuth[elevation];
  // contribution of front
  this.level = 0;
  this.level += 0.5 * buff_rms(buff_front) * sin_azimuth[azimuth] * this.elevation_mult;
  this.level += 0.5 * buff_rms(buff_left) * sin_azimuth[(azimuth + box_width * 0.25) % box_width] * this.elevation_mult;
  this.level += 0.5 * buff_rms(buff_right) * sin_azimuth[(azimuth + box_width * 0.75) % box_width] * this.elevation_mult;
  this.level += 0.5 * buff_rms(buff_rear) * sin_azimuth[(azimuth + box_width * 0.5) % box_width] * this.elevation_mult;
  this.level;
);

// How long do we calculate the RMS over?
buff_size_ms = 100;
buff_size_samples = floor(srate / 1000 * buff_size_ms);

// sin_azimuth is the half cycle of a sin wave over box_width
sin_azimuth = malloc(box_width);
index = 0; loop(box_width,
  sin_azimuth[index] = sin(index * box_width_inverse * $pi);
  index += 1;
);

// cos_elevation is the quarter cycle of cos wave over box_heights
cos_elevation = malloc(box_height);
index = 0; loop(box_height,
  cos_elevation[index] = cos(index * box_height_inverse * $pi * 0.5);
  index += 1;
);

buff_front = create_buffer(buff_size_samples);
buff_right = create_buffer(buff_size_samples);
buff_left = create_buffer(buff_size_samples);
buff_rear = create_buffer(buff_size_samples);


@sample
a_w = spl0 * sqrt2;
a_x = spl1;
a_y = spl2;
a_z = spl3;

half_w = a_w * 0.5;
buff_push(buff_front, half_w + a_x * 0.5);
buff_push(buff_rear,  half_w - a_x * 0.5);
buff_push(buff_left,  half_w + a_y * 0.5);
buff_push(buff_right, half_w - a_y * 0.5);


@block
buffMin = 0;
buffMax= 0;
index = 4;
// note that buff does NOT contain all samples since the last block
loop(buff_front[0],
  buff_front[index] > buffMax ? (buffMax = buff_front[index]);
  buff_front[index] < buffMin ? (buffMin = buff_front[index]);
  index += 1;
);


@gfx 360 360

half_width = gfx_w / 2;
half_height = gfx_h / 2;

////////////////////////////////////////////////////////////////
//
// Draw a box around the region we will render to
//
////////////////////////////////////////////////////////////////

// The origin is the upper left, and y axis increases downward
// box_x and box_y are the coordinates of the upper-left
// position that we will render to
box_x = half_width - (box_width * 0.5);
box_y = half_height - (box_height * 0.5);
gfx_mode = 0;
gfx_r = 0; gfx_g = 0; gfx_b = 1;
// draw a large blue box
gfx_rect(
  box_x - border,
  box_y - border,
  box_width + (border * 2),
  box_height + (border * 2)
);
// A black box inside the blue box is our render canvas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(box_x, box_y, box_width, box_height);



////////////////////////////////////////////////////////////////
//
// Show where power is allocated.
//
////////////////////////////////////////////////////////////////

function draw_region()(


  // additive mode for the draw loop
  gfx_mode = 1;

  // setup our outer loop on the y axis
  gfx_y = box_y;
  y = 0;
  loop(box_height,

    // setup our inner loop on the x axis
    gfx_x = box_x;
    x = 0;
    loop(box_width,

      this.level = calculate_level(x, y);
      gfx_setpixel(this.level, 0, 0);

      gfx_x += 1;
      x += 1;
    );

    gfx_y += 1;
    y += 1;
  );
);

draw_region();

