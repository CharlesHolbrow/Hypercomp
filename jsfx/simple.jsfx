desc: 'A simple meter that utilizes js gfx scripting'

slider1:0<0, 1, 0.01>first
slider2:1<0, 4, 1>second


@slider
shift_left = slider1 * $pi;


@init
malloc_ptr = 0;
function malloc(size)(
  this.ptr = malloc_ptr;
  this.i = 0;
  loop(size,
    malloc_ptr[this.i] = 0;
    this.i += 1;
  );
  malloc_ptr += size;
  this.ptr;
);

function create_buffer(size)(
  this.buff = malloc(size + 4);
  // the first four memory locations store meta-data about the buffer
  // - buff[0] stores the size of the audio buffer in samples
  // - buff[1] stores the position in the buffer relative to this.buff
  // - buff[2] stores the sum of the square of each sample
  // - buff[3] stores the RMS over the buffer
  this.buff[0] = size;
  this.buff[1] = 4;
  buff;
);

// Add a value to the buffer, keeping all meta-data up to date.
function buff_push(buff, value)(
  buff[2] -= pow(buff[buff[1]], 2);
  buff[buff[1]] = value;
  buff[2] += pow(value, 2);
  buff[3] = sqrt(buff[2] / buff[0]);

  buff[1] += 1;
  buff[1] >= (buff[0] + 4) ? (buff[1] = 4;);
);

function buff_rms(buff)(
  buff[3];
);

// How big is the region we render to?
box_width = 360;
box_height = 360;
box_width_inverse = 1 / box_width;
box_height_inverse = 1 / box_height;
border = 2;

buff = create_buffer(srate);


@sample
aW = spl0;
aX = spl1;
aY = spl2;
aZ = spl3;

// Calculate the RMS of buff
buff_push(buff, aW); // TODO: aW * sqrt(2); aW * 0.5; aX * 0.5; aW + aX;
rms = buff_rms(buff);
b0 = buff[0];


@block
buffMin = 0;
buffMax= 0;
index = 4;
// note that buff does NOT contain all samples since the last block
loop(buff[0],
  buff[index] > buffMax ? (buffMax = buff[index]);
  buff[index] < buffMin ? (buffMin = buff[index]);
  index += 1;
);

@gfx 360 360

half_width = gfx_w / 2;
half_height = gfx_h / 2;

////////////////////////////////////////////////////////////////
//
// Draw a box around the region we will render to
//
////////////////////////////////////////////////////////////////

// The origin is the upper left, and y axis increases downward
// box_x and box_y are the coordinates of the upper-left
// position that we will render to
box_x = half_width - (box_width * 0.5);
box_y = half_height - (box_height * 0.5);
gfx_mode = 0;
gfx_r = 0; gfx_g = 0; gfx_b = 1;
// draw a large blue box
gfx_rect(
  box_x - border,
  box_y - border,
  box_width + (border * 2),
  box_height + (border * 2)
);
// A black box inside the blue box is our render canvas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(box_x, box_y, box_width, box_height);


////////////////////////////////////////////////////////////////
//
// Show where power is allocated.
//
////////////////////////////////////////////////////////////////

function draw_region(gain, shift_left)(


  // additive mode for the draw loop
  gfx_mode = 1;

  // setup our outer loop on the y axis
  gfx_y = box_y;
  y = 0;
  loop(box_height,

    // setup our inner loop on the x axis
    gfx_x = box_x;
    x = 0;
    loop(box_width,

      level = abs(sin(x * box_width_inverse * $pi + shift_left)) * gain;
      level *= abs(sin(y * box_width_inverse * $pi + shift_up)) * gain;
      gfx_setpixel(level, 0, 0);

      gfx_x += 1;
      x += 1;
    );

    gfx_y += 1;
    y += 1;
  );
);

draw_region(slider1, 0);
draw_region(1 - slider1, 0.5 * $pi);
