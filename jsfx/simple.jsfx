desc: 'A simple meter that utilizes js gfx scripting'

slider1:0<0, 1, 0.01>first
slider2:1<0, 4, 1>second


@slider
shift_left = slider1 * $pi;


@init
k_sqrt2 = sqrt(2);

malloc_ptr = 0;
function malloc(size)(
  this.ptr = malloc_ptr;
  this.i = 0;
  loop(size,
    malloc_ptr[this.i] = 0;
    this.i += 1;
  );
  malloc_ptr += size;
  this.ptr;
);

function create_buffer(size)(
  this.buff = malloc(size + 4);
  // the first four memory locations store meta-data about the buffer
  // - buff[0] stores the size of the audio buffer in samples
  // - buff[1] stores the position in the buffer relative to this.buff
  // - buff[2] stores the sum of the square of each sample
  // - buff[3] stores the RMS over the buffer
  this.buff[0] = size;
  this.buff[1] = 4;
  this.buff;
);

// Add a value to the buffer, keeping all meta-data up to date.
function buff_push(buff, value)(
  buff[2] -= pow(buff[buff[1]], 2);
  buff[buff[1]] = value;
  buff[2] += pow(value, 2);
  buff[3] = sqrt(buff[2] / buff[0]);

  buff[1] += 1;
  buff[1] >= (buff[0] + 4) ? (buff[1] = 4;);
);

function buff_rms(buff)(
  buff[3];
);

// How big is the region we render to?
box_width = 360;
box_height = 360;
box_width_inverse = 1 / box_width;
box_height_inverse = 1 / box_height;
border = 2;

// How long to we calculate the RMS over?
buff_size_ms = 100;
buff_size_samples = floor(srate / 1000 * buff_size_ms);

buff_front = create_buffer(buff_size_samples);
buff_right = create_buffer(buff_size_samples);
buff_left = create_buffer(buff_size_samples);
buff_rear = create_buffer(buff_size_samples);


@sample
a_w = spl0 * k_sqrt2;
a_x = spl1;
a_y = spl2;
a_z = spl3;

half_w = a_w * 0.5;
buff_push(buff_front, half_w + a_x * 0.5);
buff_push(buff_rear,  half_w - a_x * 0.5);
buff_push(buff_left,  half_w + a_y * 0.5);
buff_push(buff_right, half_w - a_y * 0.5);


@block
buffMin = 0;
buffMax= 0;
index = 4;
// note that buff does NOT contain all samples since the last block
loop(buff_front[0],
  buff_front[index] > buffMax ? (buffMax = buff_front[index]);
  buff_front[index] < buffMin ? (buffMin = buff_front[index]);
  index += 1;
);

rms_left = buff_rms(buff_left);
rms_right = buff_rms(buff_right);
rms_front = buff_rms(buff_front);

@gfx 360 360

half_width = gfx_w / 2;
half_height = gfx_h / 2;

////////////////////////////////////////////////////////////////
//
// Draw a box around the region we will render to
//
////////////////////////////////////////////////////////////////

// The origin is the upper left, and y axis increases downward
// box_x and box_y are the coordinates of the upper-left
// position that we will render to
box_x = half_width - (box_width * 0.5);
box_y = half_height - (box_height * 0.5);
gfx_mode = 0;
gfx_r = 0; gfx_g = 0; gfx_b = 1;
// draw a large blue box
gfx_rect(
  box_x - border,
  box_y - border,
  box_width + (border * 2),
  box_height + (border * 2)
);
// A black box inside the blue box is our render canvas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(box_x, box_y, box_width, box_height);


////////////////////////////////////////////////////////////////
//
// Show where power is allocated.
//
////////////////////////////////////////////////////////////////

function draw_region(gain, shift_left)(


  // additive mode for the draw loop
  gfx_mode = 1;

  // setup our outer loop on the y axis
  gfx_y = box_y;
  y = 0;
  loop(box_height,

    // setup our inner loop on the x axis
    gfx_x = box_x;
    x = 0;
    loop(box_width,

      level = abs(sin(x * box_width_inverse * $pi + shift_left)) * gain;
      level *= abs(sin(y * box_width_inverse * $pi + shift_up)) * gain;
      gfx_setpixel(level, 0, 0);

      gfx_x += 1;
      x += 1;
    );

    gfx_y += 1;
    y += 1;
  );
);

draw_region(buff_rms(buff_front), 0);
draw_region(buff_rms(buff_right), 0.75 * $pi);
draw_region(buff_rms(buff_left), 0.25 * $pi);
draw_region(buff_rms(buff_rear), 0.5 * $pi);
