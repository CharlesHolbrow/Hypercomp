desc: Ambisonic Compressor
slider1:0.75<0, 1, 0.01>Display Threshold
slider2:1<0, 2, 0.01>Scale Brightness
slider3:0.5<0, 1, 0.1>Misc

filename:0,left_x72.png
filename:1,right_x72.png
filename:2,front_x72.png
filename:3,rear_x72.png
filename:4,above_x72.png
filename:5,below_x72.png


@slider
display_threshold = slider1 * slider1;


@init
// Set analysis resolution.
box_width = 440;
box_height = 220;
// For display only, draw a border around the visulization rectangle
border = 2;

// How long do we calculate the RMS over?
buff_size_ms = 100;
buff_size_samples = floor(srate / 1000 * buff_size_ms);

// Cached some constants
box_width_inverse = 1 / box_width;
box_height_inverse = 1 / box_height;
sqrt2 = sqrt(2);

// My very simple memory allocator. We never need to free
// memory, so our program code is responsible for keeping
// track of how large each block of memory is. 
malloc_ptr = 0;
function malloc(size)(
  this.ptr = malloc_ptr;
  this.i = 0;
  loop(size,
    malloc_ptr[this.i] = 0;
    this.i += 1;
  );
  malloc_ptr += size;
  this.ptr;
);

// Allocate an audio buffer
// the first four memory locations store meta-data about the buffer
// - buff[0] stores the number of audio samples this buffer can store
// Assuming we use buff_push to add each sample to our buffer:
// - buff[1] stores the position where we will place the next sample (relative to this.buff)
// - buff[2] stores the sum of the square of each sample
// - buff[3] stores the RMS of the buffer
function create_buffer(size_in_samples)(
  this.buff = malloc(size_in_samples + 4);
  this.buff[0] = size_in_samples;
  this.buff[1] = 4;
  this.buff;
);

// Add a value to the buffer, keeping all meta-data up to date.
function buff_push(buff, value)(
  buff[2] -= pow(buff[buff[1]], 2);
  buff[buff[1]] = value;
  buff[2] += pow(value, 2);
  buff[3] = sqrt(buff[2] / buff[0]);

  buff[1] += 1;
  buff[1] >= (buff[0] + 4) ? (buff[1] = 4;);
);

// Retrieve the RMS of buff
function buff_rms(buff)(
  buff[3];
);

////////////////////////////////////////////////////////////////
//
// We know the resolution at which we are calculating the sound
// field, so we can cache most of the interpolation values.
//
////////////////////////////////////////////////////////////////

// sin_azimuth is the half cycle of a sin wave over box_width
sin_azimuth = malloc(box_width);
index = 0; loop(box_width,
  sin_azimuth[index] = sin(index * box_width_inverse * $pi);
  index += 1;
);

// cos_elevation is the quarter cycle of cos wave over box_height
cos_elevation = malloc(box_height);
index = 0; loop(box_height,
  cos_elevation[index] = cos(index * box_height_inverse * $pi * 0.5);
  index += 1;
);

// cos_half_elevation is a quarter cycle of cos over half of box_height
cos_half_elevation = malloc(box_height);
index = 0; loop(box_height / 2,
  cos_half_elevation[index] = cos(index * box_height_inverse * $pi);
  index += 1;
);

// sin_half_elevation is a quarter cycle of a sine wave centered on the peak
sin_half_elevation = malloc(box_height);
index = 0; loop(box_height,
  sin_half_elevation[index] = sin(index * box_height_inverse * $pi * 0.5 + ($pi * 0.25));
  index += 1;
);

// linear_elevation is a linear ramp from 1 to 0 over box_height
linear_elevation = malloc(box_height);
index = 0; loop(box_height,
  linear_elevation[index] = 1 - (index * box_height_inverse);
  index += 1;
);

buff_front = create_buffer(buff_size_samples);
buff_right = create_buffer(buff_size_samples);
buff_left = create_buffer(buff_size_samples);
buff_rear = create_buffer(buff_size_samples);
buff_top = create_buffer(buff_size_samples);
buff_bottom = create_buffer(buff_size_samples);

// For a given azimuth and elevation, calculate the level. The
// units of both arguments are integers relative to box_height
// and box_width.
function calculate_level(azimuth elevation)(
  this.elevation_mult = sin_half_elevation[elevation];
  this.level = 0;
  this.level += buff_rms(buff_front) * sin_azimuth[azimuth] * this.elevation_mult;
  this.level += buff_rms(buff_left) * sin_azimuth[(azimuth + box_width * 0.25) % box_width] * this.elevation_mult;
  this.level += buff_rms(buff_right) * sin_azimuth[(azimuth + box_width * 0.75) % box_width] * this.elevation_mult;
  this.level += buff_rms(buff_rear) * sin_azimuth[(azimuth + box_width * 0.5) % box_width]   * this.elevation_mult;
  // I don't quite understand why we need to scale the elevation axis, but adding this makes things work correctly
  this.elevation_scale = sqrt2;
  this.level += buff_rms(buff_top) * linear_elevation[elevation] * this.elevation_scale;
  this.level += buff_rms(buff_bottom) * linear_elevation[box_height - elevation - 1] * this.elevation_scale;
  this.level / this.elevation_scale;
);


@sample
a_w = spl0 * sqrt2;
a_x = spl1;
a_y = spl2;
a_z = spl3;

half_w = a_w * 0.5;
buff_push(buff_front, half_w + a_x * 0.5);
buff_push(buff_rear,  half_w - a_x * 0.5);
buff_push(buff_left,  half_w + a_y * 0.5);
buff_push(buff_right, half_w - a_y * 0.5);
buff_push(buff_top, half_w + a_z * 0.5);
buff_push(buff_bottom, half_w - a_z * 0.5);


////////////////////////////////////////////////////////////////
//
// Execute gfx code approximately 30 times per second. Note that
// it runs on a separate thread from audio processing above. 
//
////////////////////////////////////////////////////////////////
@gfx 360 360

half_width = gfx_w / 2;
half_height = gfx_h / 2;

// Draw a box around the region we will render to.
//
// The origin is the upper left, and y axis increases downward
// box_x and box_y are the coordinates of the upper-left
// position that we will render to
box_x = half_width - (box_width * 0.5);
box_y = half_height - (box_height * 0.5);
gfx_mode = 0;
gfx_r = 0; gfx_g = 0; gfx_b = 1; gfx_a = 1;
// draw a large blue box
gfx_rect(
  box_x - border,
  box_y - border,
  box_width + (border * 2),
  box_height + (border * 2)
);
// A black box inside the blue box is our render canvas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(box_x, box_y, box_width, box_height);

// keep track of these stats for each frame
max_level_temp = 0;
total = 0;

// additive mode for the draw loop
gfx_mode = 1;

// setup our outer loop on the y axis
gfx_y = box_y;
y = 0;
loop(box_height,

  // setup our inner loop on the x axis
  gfx_x = box_x;
  x = 0;
  loop(box_width,

    level = calculate_level(x, y);
    // Track the highest pixel value in this frame
    level > max_level_temp ? max_level_temp = level;
    // Summation of all pixels in this frame
    total += level;

    // condition for viewing
    level = pow(level, slider2);
    level -= display_threshold;
    level *= 1/(1 - display_threshold);

    gfx_setpixel(level, 0, 0);

    gfx_x += 1;
    x += 1;
  );

  gfx_y += 1;
  y += 1;
);

max_level = max_level_temp;
avg_level = max_level / (box_width * box_height);

gfx_mode = 1; // Additive Mode
gfx_x = 0; gfx_y = 0;
gfx_a = buff_rms(buff_left);
gfx_blit(0, 1, 0);
gfx_a = buff_rms(buff_right);
gfx_blit(1, 1, 0);
gfx_a = buff_rms(buff_front);
gfx_blit(2, 1, 0);
gfx_a = buff_rms(buff_rear);
gfx_blit(3, 1, 0);
gfx_a = buff_rms(buff_top);
gfx_blit(4, 1, 0);
gfx_a = buff_rms(buff_bottom);
gfx_blit(5, 1, 0);
