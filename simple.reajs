desc: 'A simple meter that utilizes js gfx scripting'

slider1:1<0, 1, 0.01>first
slider2:1<0, 4, 1>second

@slider
mult1 = cos($pi*slider1/2) * .707;
mult2 = sin($pi*slider1/2) * .707;

@init
wBuff = 0;
wBuffPosition = 0;
wBuffTotal = 0;
wBuffRMS = 0;

// Clear the buffer;
index = 0;
loop(srate,
  wBuff[index] = 0;
  index += 1;
)

@sample
w = spl0;
x = spl1;
y = spl2;
z = spl3;

// Calculate the RMS of w buffer
wBuffTotal -= pow(wBuff[wBuffPosition], 2);
wBuff[wBuffPosition] = w;
wBuffTotal += pow(w, 2);
wBuffRMS = sqrt(wBuffTotal / srate);

wBuffPosition += 1;
wBuffPosition >= srate ? (wBuffPosition = 0;);

@gfx 360 360

quarter_width = gfx_w / 4;
half_width = gfx_w / 2;
half_height = gfx_h / 2;

gfx_r = 0; gfx_g = 0; gfx_b = 1;
gfx_rect(half_width - 181, half_height - 181, 362, 362);
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(half_width - 180, half_height - 180, 360, 360);

position_in_degrees = - 90;
loop(180, // for now it's okay to consider our resolution equal to a value in degrees
  level = cos(position_in_degrees * $pi / 180) * mult1;// * wBuffRMS;
  // for now, gfx_x, gfx_y are equal to degrees, because the window size is 360x360
  gfx_x = half_width + position_in_degrees;
  gfx_y =  half_height;
  gfx_setpixel(level, 0, 0);
  loop(30,
    gfx_y += 1; gfx_setpixel(level, 0, 0);
  );
  position_in_degrees += 1;
);

position_in_degrees = 0;
loop(180,
  level = sin(position_in_degrees * $pi / 180) * mult2;
  gfx_x = half_width + position_in_degrees;
  gfx_y = half_height;
  gfx_getpixel(r, g, b);
  gfx_setpixel(level + r, g, b);
  loop(30,
    gfx_y += 1; gfx_setpixel(level + r, g, b);
  );
  gfx_y += 1; gfx_setpixel(1, 0, 0);
  gfx_y += 1; gfx_setpixel(1, 0, 0);
  gfx_y += 1; gfx_setpixel(1, 0, 0);
  gfx_y += 1; gfx_setpixel(1, 0, 0);
  position_in_degrees += 1;
);

